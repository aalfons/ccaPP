\name{maxCorGrid}
\alias{maxCorGrid}
\alias{print.maxCor}
\alias{sMaxCorGrid}
\title{(Robust) maximum correlation via alternating series of grid searches}
\usage{
  maxCorGrid(x, y,
    method = c("spearman", "kendall", "quadrant", "M", "pearson"),
    control = list(...), nIterations = 10, nAlternate = 10,
    nGrid = 25, select = NULL, tol = 1e-06,
    standardize = TRUE, fallback = FALSE, seed = NULL, ...)

  sMaxCorGrid(x, y, lambdaX = 0, lambdaY = 0,
    method = c("spearman", "kendall", "quadrant", "M", "pearson"),
    control = list(...), nIterations = 10, nAlternate = 10,
    nGrid = 25, select = NULL, tol = 1e-06,
    standardize = TRUE, fallback = FALSE, K = 5, R = 1,
    type = c("random", "consecutive", "interleaved"),
    grouping = NULL, folds = NULL, nCores = 1, cl = NULL,
    seed = NULL, ...)
}
\arguments{
  \item{x,y}{each can be a numeric vector, matrix or data
  frame.}

  \item{lambdaX,lambdaY}{numeric vectors of non-negative
  values giving the penalty parameters for the weighting
  vectors of \code{x} and \code{y}, respectively.}

  \item{method}{a character string specifying the
  correlation functional to maximize.  Possible values are
  \code{"spearman"} for the Spearman correlation,
  \code{"kendall"} for the Kendall correlation,
  \code{"quadrant"} for the quadrant correlation,
  \code{"M"} for the correlation based on a bivariate
  M-estimator of location and scatter with a Huber loss
  function, or \code{"pearson"} for the classical Pearson
  correlation (see \code{\link{corFunctions}}).}

  \item{control}{a list of additional arguments to be
  passed to the specified correlation functional.  If
  supplied, this takes precedence over additional arguments
  supplied via the \code{\dots} argument.}

  \item{nIterations}{an integer giving the maximum number
  of iterations.}

  \item{nAlternate}{an integer giving the maximum number of
  alternate series of grid searches in each iteration.}

  \item{nGrid}{an integer giving the number of equally
  spaced grid points on the unit circle to use in each grid
  search.}

  \item{select}{optional; either an integer vector of
  length two or a list containing two index vectors.  In
  the first case, the first integer gives the number of
  variables of \code{x} to be randomly selected for
  determining the order of the variables of \code{y} in the
  corresponding series of grid searches, and vice versa for
  the second integer.  In the latter case, the first list
  element gives the indices of the variables of \code{x} to
  be used for determining the order of the variables of
  \code{y}, and vice versa for the second integer (see
  \dQuote{Details}).}

  \item{tol}{a small positive numeric value to be used for
  determining convergence.}

  \item{standardize}{a logical indicating whether the data
  should be (robustly) standardized.}

  \item{fallback}{logical indicating whether a fallback
  mode for robust standardization should be used.  If a
  correlation functional other than the Pearson correlation
  is maximized, the first attempt for standardizing the
  data is via median and MAD.  In the fallback mode,
  variables whose MADs are zero (e.g., dummy variables) are
  standardized via mean and standard deviation.  Note that
  if the Pearson correlation is maximized, standardization
  is always done via mean and standard deviation.}

  \item{K,R,type,grouping}{additional arguments for
  generating cross-validation folds (see
  \code{\link{cvFolds}}).}

  \item{folds}{an object of class \code{"cvFolds"} (as
  returned by \code{\link{cvFolds}}) defining the folds of
  the data for cross-validation. If supplied, this is
  preferred over the arguments for generating
  cross-validation folds.}

  \item{nCores}{a positive integer giving the number of
  processor cores to be used for parallel computing in
  cross-validation (the default is 1 for no
  parallelization).  If this is set to \code{NA}, all
  available processor cores are used.}

  \item{cl}{a \pkg{parallel} cluster for parallel computing
  to be used in cross-validation, as generated by
  \code{\link[parallel]{makeCluster}}.  If supplied, this
  is preferred over \code{nCores}.}

  \item{seed}{optional initial seed for the random number
  generator (see \code{\link{.Random.seed}}).  This is only
  used if \code{select} specifies the numbers of variables
  of each data set to be randomly selected for determining
  the order of the variables of the respective other data
  set.}

  \item{\dots}{additional arguments to be passed to the
  specified correlation functional.}
}
\value{
  An object of class \code{"maxCor"} with the following
  components:

  \item{cor}{a numeric giving the maximum correlation
  estimate.}

  \item{a}{numeric; the weighting vector for \code{x}.}

  \item{b}{numeric; the weighting vector for \code{y}.}

  \item{centerX}{a numeric vector giving the center
  estimates used in standardization of \code{x}.}

  \item{centerY}{a numeric vector giving the center
  estimates used in standardization of \code{y}.}

  \item{scaleX}{a numeric vector giving the scale estimates
  used in standardization of \code{x}.}

  \item{scaleY}{a numeric vector giving the scale estimates
  used in standardization of \code{y}.}

  \item{lambdaX}{a numeric giving the optimal penalty
  parameter for the weighting vector of \code{x} (only
  \code{sMaxCorGrid}).}

  \item{lambdaY}{a numeric giving the optimal penalty
  parameter for the weighting vector of \code{y} (only
  \code{sMaxCorGrid}).}

  \item{objective}{a numeric giving the value of the
  objective function for the optimal combination of penalty
  parameters (only \code{sMaxCorGrid}).}

  \item{cv}{a numeric matrix containing the (average)
  results from cross-validation for each combination of
  penalty parameters (only \code{sMaxCorGrid} and if a grid
  of values for the penalty parameters has been supplied).}

  \item{call}{the matched function call.}
}
\description{
  Compute the maximum correlation between two data sets via
  projection pursuit based on alternating series of grid
  searches in two-dimensional subspaces of each data set,
  with a focus on robust and nonparametric methods.
}
\details{
  \code{maxCorGrid} is based on alternating series of grid
  searches in two-dimensional subspaces of each data set.
  In each grid search, \code{nGrid} grid points on the unit
  circle in the corresponding plane are obtained, and the
  directions from the center to each of the grid points are
  examined.  In the first iteration, equispaced grid points
  in the interval \eqn{[-\pi/2, \pi/2)}{[-pi/2, pi/2)} are
  used.  In each subsequent iteration, the angles are
  halved such that the interval \eqn{[-\pi/4,
  \pi/4)}{[-pi/4, pi/4)} is used in the second iteration
  and so on.  If only one data set is multivariate, the
  algorithm simplifies to iterative grid searches in
  two-dimensional subspaces of the corresponding data set.

  In the basic algorithm, the order of the variables in a
  series of grid searches for each of the data sets is
  determined by the average absolute correlations with the
  variables of the respective other data set.  Since this
  requires to compute the full \eqn{(p \times q)}{(p x q)}
  matrix of absolute correlations, where \eqn{p} denotes
  the number of variables of \code{x} and \eqn{q} the
  number of variables of \code{y}, a faster modification is
  available as well.  In this modification, the average
  absolute correlations are computed over only a subset of
  the variables of the respective other data set.  It is
  thereby possible to use randomly selected subsets of
  variables, or to specify the subsets of variables
  directly.

  Note that also the data sets are ordered according to the
  maximum average absolute correlation with the respective
  other data set to ensure symmetry of the algorithm.

  \code{sMaxCorGrid} enforces sparsity by adding
  \eqn{L_{1}}{L1} penalties on the weighting vectors to the
  objective function (i.e., the correlation of the
  resulting projections).  The optimal combination of
  penalty paramters is thereby determined via
  cross-validation over a grid of values.  To increase the
  computational performance of this cross-validation
  procedure, parallel computing is implemented via package
  \pkg{parallel}.
}
\examples{
## generate data
library("mvtnorm")
set.seed(1234)  # for reproducibility
p <- 3
q <- 2
m <- p + q
sigma <- 0.5^t(sapply(1:m, function(i, j) abs(i-j), 1:m))
xy <- rmvnorm(100, sigma=sigma)
x <- xy[, 1:p]
y <- xy[, (p+1):m]

## Spearman correlation
maxCorGrid(x, y, method = "spearman")
maxCorGrid(x, y, method = "spearman", consistent = TRUE)

## Pearson correlation
maxCorGrid(x, y, method = "pearson")
}
\author{
  Andreas Alfons
}
\seealso{
  \code{\link{maxCorProj}}, \code{\link{ccaGrid}},
  \code{\link{corFunctions}}
}
\keyword{multivariate}
\keyword{robust}

